#include "TEA.H"


//TEA密钥
uint8 TEA_key[16]=
{ 
    0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,
    0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,0x10
};

/********************************************************************* 
*                           函数 
**********************************************************************/  
  /********************************************************************* 
*                           tea加密 
*参数:v:要加密的数据,长度为8字节 
*     k:加密用的key,长度为16字节 
**********************************************************************/  
  
static void tea_encrypt(uint32 *v,uint32 *k);  
  
/********************************************************************* 
*                           tea解密 
*参数:v:要解密的数据,长度为8字节 
*     k:解密用的key,长度为16字节 
**********************************************************************/  
  
static void tea_decrypt(uint32 *v,uint32 *k);  
/********************************************************************* 
*                           tea加密 
*参数:v:要加密的数据,长度为8字节 
*     k:加密用的key,长度为16字节 
**********************************************************************/  

static void tea_encrypt(uint32 *v,uint32 *k)   
{  
    uint32 y = v[0],z = v[1],sum = 0,i;          
    uint32 delta = 0x9e3779b9;                  
    uint32 a = k[0],b = k[1],c = k[2],d = k[3];    
      
    for (i = 0;i < 32;i++)   
    {                          
        sum += delta;  
        y += ((z << 4) + a) ^ (z + sum) ^ ((z >> 5) + b);  
        z += ((y << 4) + c) ^ (y + sum) ^ ((y >> 5) + d);  
    }  
    v[0] = y;  
    v[1] = z;  
}  
  
/********************************************************************* 
*                           tea解密 
*参数:v:要解密的数据,长度为8字节 
*     k:解密用的key,长度为16字节 
**********************************************************************/  

static void tea_decrypt(uint32 *v,uint32 *k)   
{  
    uint32 y = v[0],z = v[1],sum = 0xC6EF3720,i;   
    uint32 delta = 0x9e3779b9;              
    uint32 a = k[0],b = k[1],c = k[2],d = k[3];      
      
    for (i = 0;i < 32;i++)   
    {                           
        z -= ((y << 4) + c) ^ (y + sum) ^ ((y >> 5) + d);  
        y -= ((z << 4) + a) ^ (z + sum) ^ ((z >> 5) + b);  
        sum -= delta;                       
    }  
    v[0] = y;  
    v[1] = z;  
}  
  
/********************************************************************* 
*                           加密算法 
*参数:src:源数据,所占空间必须为8字节的倍数.加密完成后密文也存放在这 
*     size_src:源数据大小,单位字节 
*     key:密钥,16字节 
*返回:密文的字节数 
**********************************************************************/  
  
extern uint16 encrypt(uint8 *src,uint16 size_src,uint8 *key)  
{  
    uint8 a = 0;  
    uint16 i = 0;  
    uint16 num = 0;  
      
    //将明文补足为8字节的倍数   
    a = size_src % 4;  
    if (a != 0)  
    {  
        for (i = 0;i < 4 - a;i++)  
        {  
            src[size_src++] = 0;  
        }  
    }  
      
    //加密   
    num = size_src / 4;  
    for (i = 0;i < num;i++)  
    {  
        tea_encrypt((uint32 *)(src + i * 4),(uint32 *)key);  
    }  
      
    return size_src;  
}  
  
/********************************************************************* 
*                           解密算法 
*参数:src:源数据,所占空间必须为8字节的倍数.解密完成后明文也存放在这 
*     size_src:源数据大小,单位字节 
*     key:密钥,16字节 
*返回:明文的字节数,如果失败,返回0 
**********************************************************************/  
  
extern uint16 decrypt(uint8 *src,uint16 size_src,uint8 *key)  
{  
    uint16 i = 0;  
    uint16 num = 0;  
      
    //判断长度是否为8的倍数   
    if (size_src % 4 != 0)  
    {  
        return 0;  
    }  
      
    //解密   
    num = size_src / 4;  
    for (i = 0;i < num;i++)  
    {  
        tea_decrypt((uint32 *)(src + i * 4),(uint32 *)key);  
    }  
      
    return size_src;  
}  




extern uint32 WORD16_TO_WORD32(uint16 x, uint16 y)
{
	uint32 r = 0;
	r = SWAP_WORD16(x);
	r <<= 16;
	r += SWAP_WORD16(y);
	return r;
}

